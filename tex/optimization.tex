\chapter{AV1低延迟直播系统构建与优化}

\section{AV1低延迟直播系统构建}
	一个通用的直播系统需要包括采集端、业务服务器、CDN部署以及播放端。本文所搭建的AV1低延迟直播系统实验性系统，目标是探索基于AV1的直播系统的低延迟极限。AV1低延迟直播系统原型如图\ref{fig:av1-sys}构建，主播端摄像头采集图像或使用录屏，进行H.264编码后，通过SRT协议传输到转码服务器，转码服务器使用FFmpeg，调用SVT-AV1编码器将接收到的码流进行H.264到AV1的转码，转码后进行RTP封装，通过RTSP协议传输到观众端解码播放。

  \begin{figure}[!htp]
    \centering
    \includegraphics[width=0.7\textwidth]{av1-sys.pdf}
    \caption{AV1低延迟直播系统原型}
   \label{fig:av1-sys}
  \end{figure}

  AV1低延迟直播系统原型基于FFmpeg搭建。FFmpeg是一个用于记录，转换和传输音视频流的完整开源解决方案，\texttt{ffmpeg}命令行程序本身为一个转码框架，可以根据需求将输入的音视频流执行解封装、转码、滤镜处理后进行封装、传输。所搭建的AV1低延迟直播系统原型使用以下组件：
	\begin{enumerate} [label=\arabic*)]
		\item 主播端：\texttt{ffmpeg, libx264, libsrt}
		\item 转码服务器端：\texttt{ffmpeg, libSvtAv1Enc, libsrt}
		\item 客户端：\texttt{ffplay, libdav1d}
	\end{enumerate}
\subsection{FFmpeg中AV1的RTP封装实现}
	由于AV1编码的RTP封装协议\cite{RTPPayloadFormat}仍处于草案阶段，以及AV1的RTP封装协议主要用于WebRTC，在FFmpeg中并没有AV1编码的RTP封装支持，因此，为了实现AV1直播系统原型，实现了FFmpeg中AV1的RTP封装实现。

	由于RTP的packet大小限制为1500 bytes，再加上RTP头部的开销，实际payload可用大小小于1500 bytes。对于视频编码，I帧大小往往会超过这个限制，而一些P帧可能远远达不到这个限制，因此需要对OBU进行拆分和聚合，提高RTP封装的传输效率。根据图\ref{fig:av1rtp-aggr}的聚合头部规则对OBU进行拆分与聚合，封装成RTP packet进行传输，解封装时，根据RTP packet中的聚合头部，将packet解封装为OBU，传到解码器进行解码。

	这部分的实现通过在FFmpeg中加入\texttt{rtpenc\_av1.c}、\texttt{rtpdec\_av1.c}来实现对AV1编码的处理。实际实现时，考虑到OBU聚合规则可能引起的延迟，为了达到尽可能低的延迟，仅对超过RTP payload大小的包进行拆分，不进行聚合。

	\begin{figure}[!htp]
		\centering
		\includegraphics[width=4cm]{av1_rtp_hdr.png} \\
		\raggedright
		\texttt{Z}: 若第一个OBU元素是延续上一个packet的片段，设1，否则设0；\\
		\texttt{Y}: 若最后一个OBU元素是一个会延续到下一个packet的片段，设1，否则设0；\\
		\texttt{W}: 描述当前packet中的OBU元素数量；\\
		\texttt{N}: 若当前packet是视频序列首个packet，设1，否则设0。\\
		\caption{AV1聚合头部}
		\label{fig:av1rtp-aggr}
	\end{figure}
\section{AV1低延迟直播系统分析与优化}

\subsection{所搭建直播系统原型延迟分析}
%enumerate or table? 测数据太麻烦了
	如图\ref{fig:av1-sys-lat}，所搭建直播系统原型延迟由各组件在各阶段的延迟累加而成，其中，主要的延迟如下：
	\begin{enumerate} [label=\arabic*)]
		\item 主播端x264编码延迟$\mathrm{L_{x264}}$；
		\item 主播端推流到转码服务器SRT协议延迟$\mathrm{L_{srt}}$；
		\item 转码服务器SVT-AV1编码器启动延迟：$\mathrm{L_{svtav1\_init}}\approx6\sim 7$s；
		\item 转码服务器SVT-AV1编码延迟：$\mathrm{L_{svtav1}}\approx 3$s；
		\item 客户端从转码服务器拉流RTSP延迟$\mathrm{L_{rtsp}}$；
		\item 客户端播放器缓冲区延迟$\mathrm{L_{ffplay}}$。
	\end{enumerate}

  \begin{figure}[!htp]
		\centering
		\includegraphics[width=0.7\textwidth]{av1-sys-lat.pdf}
		\caption{AV1低延迟直播系统原型延迟分布图}
		\label{fig:av1-sys-lat}
	\end{figure}

\subsection{SVT-AV1的高启动延迟优化}
  搭建的AV1低延迟直播系统原型带有$6\sim 7$秒左右SVT-AV1带来的高启动延迟。延迟产生的原因有两个：

  \begin{enumerate} [label=\arabic*)]
    \item \textbf{分配内存多、单线程分配。}SVT-AV1编码器在启动时需要分配大量内存，启动大量线程，本身耗时较长，SVT框架在CPU核心数较多的服务器上会分配更多的线程，而分配线程与内存的工作由单线程完成。这导致在搭载Intel Xeon8280的服务器上，SVT-AV1对于1080p视频参数的启动需要花费6秒进行初始化。
    \item \textbf{编码器启动顺序限制。}AV1直播系统原型中，SVT-AV1编码器作为FFmpeg的plugin被调用，在转码设定下，FFmpeg在服务器端会阻塞式地监听SRT传输端口，需要接收到上行码流，根据解码得到的视频相关参数后才可以进行SVT-AV1编码器初始化。二者的顺序本身不能颠倒，除非事先确定了上行码流的视频分辨率大小。
  \end{enumerate}

  % TODO 格式：enumerate的缩进和后续段落的缩进
  由以上原因，对SVT-AV1的高启动延迟优化有两种方案：

  \paragraph{优化malloc减小初始化延迟} SVT-AV1编码器在启动时会请求大量内存，实验发现，分配总量大小相同的内存块时，每次分配的内存越小、调用malloc次数越多，分配所需的总时间越长，因此可以通过将少量多次的malloc请求合并减少malloc调用次数以降低延迟。SVT-AV1的debug版本带有对malloc的profile，可以分析初始化过程中malloc被高频调用的位置。通过对高频malloc的代码进行向量化以大幅减小malloc调用次数，可以一定程度上减小SVT-AV1初始化时间。

  \begin{table}[!hpt]
    \caption{SVT-AV1 malloc优化结果}
    \label{tab:malloc}
    \centering
    \begin{tabular}{ccc} \toprule
      优化    & 初始化时间 & malloc次数\\ \midrule
      优化前  & 6.630s   & 1964126  \\
      优化后  & 5.635s   & 331625   \\ \bottomrule
    \end{tabular}
  \end{table}

  \paragraph{预启动SVT-AV1消除初始化延迟} 上述优化malloc的方法以及其他优化初始化速度的方法只能在一定程度上减小SVT-AV1的初始化时间。对于低延迟的直播系统，要求尽量减小直播系统延迟，可以通过预启动SVT-AV1编码器来消除初始化延迟，这需要约定上行码流的分辨率，因为预启动的行为本身是使用了不能预先获知的信息。在FFmpeg接收到上行码流前按照约定的分辨率预先初始化\texttt{AVCodec}，接收到上行码流后用预先初始化好的\texttt{AVCodec}，不再重新初始化，即可消除这部分延迟。

	\subsection{其他系统延迟的优化}

	主播端使用x264编码器编码，x264的调用配置需要使用\texttt{-tune zerolatency -preset ultrafast}，zerolatency会通过禁止b帧使用，关闭码率控制的lookahead等方式降低编码延迟。

	在播放器端的延迟可以通过合理配置\texttt{ffplay}降低，包括了消除播放器缓冲区的\texttt{-fflags nobuffer}以及减小\texttt{probesize}在接收到流以后快速开始播放等，具体使用的命令如下：

	\texttt{ffplay -fflags nobuffer -flags low\_delay -framedrop -probesize 32 -analyzeduration 0}
\section{本章小结}
  本章讲述了基于AV1的低延迟编码系统的构建，具体阐述了基于FFmpeg构建的直播系统的各组件，原型直播系统的构建是后续优化的基础，为了实现AV1的RTSP协议传输，在FFmpeg中实现了对AV1码流的RTP封装与解封装逻辑。初始构建的直播系统原型系统延迟较高，将在本章与后续章节中阐述逐步优化的过程。基于所构建的直播系统，在系统层面进行的优化主要是针对SVT-AV1的高启动延迟的优化和一些组建的配置优化。通过优化malloc的调用与预启动SVT-AV1编码器解决。在系统层面进行优化后，由直播系统本身导致的额外延迟基本消除。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{SVT-AV1编码器低延迟优化}

\section{SVT架构}
  Intel的可伸缩视频技术（Scalable Video Technology, SVT\cite{ScalableVideoTechnology2019})编码器体系结构是专为x86处理器设计的，并且特别针对Intel Xeon可扩展处理器进行了大幅优化。SVT架构本身与编码标准无关，它允许将编码器内核拆分为独立运行的线程，每个线程处理视频编码流水线的不同部分。这些线程在不同的处理器内核上并行运行，极大加速了视频编码。SVT-AV1是SVT架构的一个应用实例。

  SVT架构的优势在于其伸缩性，可以根据处理器的核数调整各过程的线程数，因此，对于性能较强的服务器，使用SVT架构可以有效地释放处理器性能，从而提升编码速度；对于性能较差的处理器，SVT架构并不能提升编码速度，反而因为多线程的竞争导致编码速度下降，还因为SVT架构拆分了编码器内核，引入了更多的并行，导致编码效率的下降。对于直播转码服务的场景，往往会使用性能较强的服务器处理，适合SVT架构的发挥。

\subsection{SVT-AV1编码器过程}
  SVT架构是围绕Process过程设计的\cite{EncoderDesignSVTAV1}。过程是软件中的执行线程或硬件中的IP内核。过程执行一个或多个编码器任务（例如，运动估计，速率控制，解块滤波器等）。过程分为基于图像面向控制和面向数据处理两类。控制过程仅允许单个线程实例，因为控制决策必须全局统一，否则有发生数据泄漏和死锁等情况的风险。

  以下简要介绍SVT-AV1中的各个编码器过程：
  \paragraph{资源协调过程（Resource Coordination）} 资源协调进程会收集输入的图像，创建后续编码流水线中会用到的buffer，并将输入的图像与当前的编码器设置一同传递到下一级。

  \paragraph{图像分析过程（Picture Analysis）} 图像分析过程执行编码器预处理分析的第一阶段：图片内图像转换过程，例如重采样，色彩空间转换或色调映射等、创建n-bin直方图以进行场景变化检测，收集图片中每个8x8块的一阶矩和二阶矩统计信息，用于计算方差，输入二次采样和屏幕内容检测。图片分析过程可以是多线程的。

  \paragraph{图像决策过程（Picture Decision）} 图像决策过程执行多图片级别决策，包括设置预测结构，设置图片类型和场景变化检测。由于前一级图片分析过程是多线程的，本级输入可能不按显示顺序到达，因此使用重排序队列来强制按显示顺序对图片进行处理。图像决策过程中使用的算法取决于先前图片的统计信息，因此必须严格保持图片的处理顺序。

  \paragraph{运动估计过程（Motion Estimation）} 运动估计过程使用高度可并行化的，开环的，独立于邻居的方法生成帧间预测和帧内预测候选。运动估计过程中产生的候选成本在下游过程中进一步完善，并且随着更多邻居信息的出现，可以计算出更准确的成本。运动估计由四个部分组成：分层运动估计（HME），搜索中心选择，运动估计和开环内部候选搜索（OIS）。运动估计过程是多线程的，因此只要所有输入都可用，就可以不按顺序处理图片。
  \begin{enumerate} [label=\arabic*)]
    \item HME对下采样的图片执行快速搜索，以收敛到候选搜索中心，以全图片分辨率进行全像素运动估计搜索；
    \item 搜索中心选择使用竞争方法从以下几种方法选择一个搜索中心，包括分层运动估计，时间运动矢量预测值，和外部搜索中心候选；
    \item 运动估计为正在考虑的每个划分在超级块搜索中心附近找到最佳运动矢量；
    \item OIS为每个活动块搜索所有可用的帧内亮度模式，帧内色度模式不考虑。
  \end{enumerate}

  \paragraph{码控初始化过程（Initial Rate Control）} 码控初始化过程根据在“图像分析”和“运动估计”过程中收集的数据以及在“图像决策”过程中确定的设置，确定每个图像的初始比特预算。如果允许延迟，则码控初始化过程还将采用滑动窗口缓冲区来分析多张图片。

  \paragraph{基于源的操作过程（Source Based Operation）} 基于源的操作过程涉及一些分析算法以识别输入图片的时空特征。一些操作旨在表征单个SB（例如草地区域），一些操作旨在表征整个图片（例如潜在光环区域）。

  \paragraph{图像管理过程（Picture Manager）} 图像管理过程执行管理增强输入图片缓冲区和参考图片缓冲区以及将输入图片细分为图块的功能。增强图片缓冲区和参考图片缓冲区的特定管理都取决于当前使用的GoP结构。图像管理过程使用增强图片和参考图片缓冲区来实现金字塔形B帧GoP结构。图像管理过程以异步操作模式运行，每当接收到增强输入图片或参考图片输入时，就会运行图片管理算法。图片管理算法遍历增强型输入图片缓冲区，并针对每个条目检查参考图片缓冲区中是否有必要的参考图片。如果所有参考都可用，则可以开始图片的编码。

  \paragraph{码控过程（Rate Control）} 码控过程使用在先前过程中生成的失真和图像统计信息，当前图片的比特预算和先前图片统计信息来设置每个图片的QP和比特预算。编码器当前支持VBR类型的码控。

  \paragraph{模式决策配置过程（Mode Decision Configuration）} 模式决策配置过程涉及许多初始化步骤，根据当前的编码器preset，为许多功能设置标志以及确定在后续MD阶段要考虑的模块。

  \paragraph{编码过程（ENCDEC）} 编码过程封装了分块决策阶段，在其中执行许多编码器任务，例如帧内预测，​​运动补偿预测，变换，量化和模式决策。它以运动估计过程的“运动矢量”和失真估计以及码控过程的图片级QP作为输入。编码过程以超级块为单位进行操作。下文会对编码过程有更详细的介绍。

  \paragraph{去块环路滤波过程（Deblocking Loop Filter）} 去块滤波器用于解决重构图片中的块伪像。该过滤器是基于VP9解块过滤器开发的，并在两种类型的过滤器之间切换：窄过滤器和宽过滤器。过滤首先应用于所有垂直边缘，然后再应用于所有水平边缘。

  \paragraph{约束方向增强滤波过程（Constrained Directional Enhancement Filter）} 约束方向增强滤波器（CDEF）在解块滤波器之后应用，旨在改善重构图像。CDEF是Daala编解码器的定向去环滤波器和Thor编解码器的约束低通滤波器（CLPF）的组合，并提供了定向去环滤波和约束低通滤波（CLPF）。

  \paragraph{重建滤波过程（Restortion Filter）} 恢复滤波器是在约束方向增强滤波器之后应用的，其目的是改善重建的图像。涉及两种类型的过滤器：可分离对称维纳滤波器，由于对称性，比特流中仅包含一半滤波器系数；具有子空间投影的自导恢复滤镜，具有保留边缘的平滑效果。

  \paragraph{熵编码过程（Entropy Coding）} 熵编码过程负责为每个帧产生符合AV1的比特流。它以每个块的编码决策和信息为输入，并以每个帧为输出产生比特流。熵编码器是基于帧的过程，并且基于多符号算术范围编码。

  \paragraph{打包过程（Packetization）} 打包过程从每个帧中收集比特流，对时间定界符（TD）以及序列和帧头进行编码，并作为编码器流水线的终点。打包过程将每个帧的比特流以及序列和图片级别的编码设置作为输入，并按图片解码顺序生成最终的比特流。
  \begin{figure}[!htp]
    \centering
    \includegraphics[width=\textwidth]{svt-encoder-process.png}
    \caption{SVT-AV1编码器过程图\cite{EncoderDesignSVTAV1}}
  \label{fig:svt-encoder-process}
  \end{figure}

\subsection{SVT系统资源管理器}

  SVT作为可扩展编码框架的核心是将编码器内核拆分为上述的多个独立运行的过程，这些过程可以根据处理器核心数量实例化为不同数量的线程，SVT系统资源管理器在这其中起到至关重要的作用\cite{EncoderDesignSVTAV1}。系统资源管理器执行过程间数据和控制管理。系统资源管理器通过控制对象的传递方式来管理对象并将不同过程彼此连接，几乎所有过程间通信都通过该链接进行。

  % 这张图很大，要占一页
  \begin{figure}[!htp]
    \centering
    \includegraphics[width=\textwidth]{svt-srm.png}
    \caption{SVT-AV1系统资源管理器示意图\cite{EncoderDesignSVTAV1}}
  \label{fig:svt-srm}
  \end{figure}

  图\ref{fig:svt-srm}展示了系统资源管理器的框图。如图\ref{fig:svt-srm}所示，\texttt{Empty Object DEMUX}将空对象FIFO中的空对象请求\texttt{Process MUX}分配对应的闲置生产者过程，生产者过程用数据和控制信息填充空对象，空对象被填充后成为满对象，被放入满对象FIFO。由\texttt{Full Object DEMUX}为满对象FIFO中的满对象请求\texttt{Process MUX}分配对应的闲置消费者过程。消费者过程使用满对象中的信息进行相应的处理，并通过将现在空对象放回到原始的空对象FIFO中来完成数据流动路径。

  需要注意的是，每个编码器过程既是对象的生产者又是对象的消费者，在当前编码器过程的开始阶段，获取上一级编码器过程生产的满对象，处理后，将结果放入当前编码器过程的空对象，递交到下一级。

  系统资源管理器动态地将对象分配给进程，以最大程度地减少空闲进程时间。另外，空对象路径和完整对象路径的单独协调允许很大的配置灵活性。例如，当生产者和消费者过程需要不同数量的计算资源时，这种灵活性非常重要。在这种情况下，系统资源管理器可能具有N个生产者和M个消费者，其中N不等于M。

  一次典型的编码器内核处理过程如下：
  \begin{enumerate} [label=\arabic*)]
    \item 从上一级内核的\texttt{Full Object DEMUX}获取一个满对象，从中提取待处理的数据或待决策的内容；
    \item 进行当前级编码器内核的处理过程；
    \item 从空对象FIFO中获取一个空对象，将处理结果放入，并将其提交到满对象队列；
    \item 释放起初获取的满对象到空对象队列；
    \item 重复第一步。
  \end{enumerate}

  \subsection{SVT架构的三重并行}
  SVT架构有三重并行：GoP级并行、帧级并行、超级块并行。
  \paragraph{GoP级并行、帧级并行} 当输入的图像帧多于一个GoP大小时，可以同时编码多个GoP。当一个GoP内，帧参考关系满足后，就可以开始对该帧进行编码。具体来讲，在SVT架构中，图像管理过程（PM）之前的过程属于编码前过程，读入图像帧后即可运行，之后的过程开始正式编码，需要参考GoP结构中的其他帧，当参考关系满足后才可以继续。
  \paragraph{超级块并行} 在编码过程（ENCDEC）中，以超级块为单位，波浪形的方式并行处理。由于每个超级块的编码依赖于其左边和上边块，因此，当一个超级块的左边块和上边块完成编码后，该超级块可进入编码。

  \subsection{SVT架构的多阶段分区、模式选择决策} \label{sec:pd-md}
  给定一个超级块可以考虑的大量块划分方式和大量预测模式，使用所有可用编码工具评估所有选项来收敛到最优分块和编码模式在计算上将非常昂贵。因此，SVT架构使用分阶段决策的方法\cite{EncoderDesignSVTAV1}，有分阶段分区决策（Partition Decisions, PD）和分阶段模式选择（Mode Decisions, MD）。

  如图\ref{fig:pd}所示，向PD阶段0输入运动估计结果以及所有可能的分区情况$N_0$，使用比较基本的工具和指标来初步评估不同候选的适应性，并将其中最优的$N_1$种候选传递到PD阶段1，并在后续PD阶段中考虑更复杂的预测和指标来评估。多阶段PD决策后渠道最优的分区决策和模式选择。

  \begin{table}[!hpt]
    \renewcommand{\arraystretch}{0.8}
    \caption{MD阶段处理的9类编码工具候选}
    \label{tab:av1-classes}
    \centering
    \begin{tabular}{cc} \toprule
      序号    & 工具 \\ \midrule
      0& Intra \\
      1& Inter (NEWMV) \\
      2& MV Pred  \\
      3& Inter-Inter compound \\
      4& Intra-Inter compound \\
      5& OBMC \\
      6& Filter Intra \\
      7& Palette prediction \\
      8& Global Motion candidates \\\bottomrule
    \end{tabular}
  \end{table}

  如图\ref{fig:md}所示，在每个PD阶段中，包含多个模式选择MD阶段。PD阶段输入的候选分为9个类别，如表\ref{tab:av1-classes}分别对应AV1的不同编码工具。引入候选类别的主要思想是确保重要类型的候选有机会出现在最后的MD阶段，并在该阶段与其他候选类别的最佳候选竞争。在每个MD阶段中使用预测工具与性能指标评估各个候选，对候选进行筛选，只有性能最好的一部分候选被传递到下一个MD阶段，越靠后的MD阶段中，更多更细致的预测工具与性能指标会被使用。



  \begin{figure}[!htp]
    \centering
    \includegraphics[width=0.7\textwidth]{pd-stages.png}
    \caption{分阶段分区决策\cite{EncoderDesignSVTAV1}}
  \label{fig:pd}
  \end{figure}

  \begin{figure}[!htp]
    \centering
    \includegraphics[width=\textwidth]{md-stages.png}
    \caption{单次分区决策中的多阶段模式选择\cite{EncoderDesignSVTAV1}}
  \label{fig:md}
  \end{figure}
  %TODO 写一下AssignSegment的伪代码？
\section{SVT架构的编码延迟profile工具} \label{sec:svt-profile}
  为了分析SVT架构的编码延迟来源，我们需要一个工具帮助我们分析SVT架构内部的延迟。具体有以下要求：
  \begin{enumerate} [label=\arabic*)]
    \item 避免profile工具对SVT-AV1本身的编码速度造成影响；
    \item 可以尽量详细地记录各线程开始、完成每项任务的时间节点。
  \end{enumerate}

  由此设计了SVT的延迟profile工具。因为直接进行文件写入或输出到stdout会对程序运行速度影响较大，选择先写入内存中的哈希表中，当编码结束后，统一写入文件，通过这种方式尽量减小对SVT本身编码速度的影响。在每次系统资源管理器进行对象获取或提交时，记录一条带有时间、过程以及处理图像或片段信息的entry。

  表\ref{tab:svt-profile}是编码一帧1080p分辨率的视频帧的延迟测量结果，为了便于展示，表格中省略了一些内容。通过分析延迟测量的结果可以了解在SVT架构下各过程的运行情况，便于分析延迟的产生以及产生对应的优化方案。

  \begin{table}[!hpt]
    \renewcommand{\arraystretch}{0.8} % 减小行间距
    \caption{SVT-AV1处理一帧时各过程延迟Profile}
    \label{tab:svt-profile}
    \centering
    \begin{tabular}{ccccccccc}
    	\toprule
    	process  & inType & outType & picNum & segIdx & TileIdx & sTime  & eTime  & duration \\ \midrule
    	RESOURCE &   0    &    0    &   0    &   -1   &   -1    &  0.00  &  0.01  &   0.01   \\
    	   PA    &   0    &    0    &   0    &   -1   &   -1    &  0.07  &  2.51  &   2.44   \\
    	   PD    &   0    &    0    &   0    &   0    &   -1    &  2.59  &  2.60  &   0.02   \\
    	   PD    &   0    &    0    &   0    &   59   &   -1    &  2.59  &  2.97  &   0.39   \\
    	   ME    &   0    &    0    &   0    &   3    &   -1    &  2.69  &  2.70  &   0.01   \\
    	   ME    &   0    &    0    &   0    &   59   &   -1    &  2.98  &  2.98  &   0.00   \\
    	  IRC    &   0    &    0    &   0    &   -1   &   -1    &  2.98  &  2.99  &   0.01   \\
    	  SRC    &   0    &    1    &   0    &   -1   &   -1    &  3.01  &  3.03  &   0.02   \\
    	   PM    &   1    &    0    &   0    &   -1   &   -1    &  3.04  &  3.10  &   0.06   \\
    	   RC    &   0    &    0    &   0    &   -1   &   -1    &  3.13  &  4.12  &   0.99   \\
    	  MDC    &   0    &    0    &   0    &   -1   &    0    &  4.17  &  6.47  &   2.29   \\
    	 ENCDEC  &   -1   &   -1    &   0    &   0    &   -1    &  6.52  & 10.45  &   3.92   \\
    	 ENCDEC  &   -1   &   -1    &   0    &  781   &   -1    & 197.22 & 199.48 &   2.26   \\
    	  DLF    &   0    &    0    &   0    &   0    &   -1    & 199.56 & 199.56 &   0.01   \\
    	  DLF    &   0    &    0    &   0    &   59   &   -1    & 199.56 & 199.93 &   0.38   \\
    	  CDEF   &   0    &    0    &   0    &   0    &   -1    & 199.83 & 262.76 &  62.93   \\
    	  REST   &   0    &    0    &   0    &   -1   &    0    & 262.87 & 263.44 &   0.57   \\
    	ENTROPY  &   0    &    2    &   0    &   0    &    0    & 263.45 & 268.00 &   4.55   \\
    	ENTROPY  &   0    &    2    &   0    &   16   &    0    & 306.02 & 310.01 &   3.99   \\
    	  PAK    &   0    &    0    &   0    &   -1   &   -1    & 310.51 & 310.93 &   0.42   \\ \bottomrule
    \end{tabular}
  \end{table}

\section{SVT架构的延迟分析}
运用\ref{sec:svt-profile}章节提到的SVT架构编码延迟profile工具对SVT-AV1编码器进行测试，延迟测试在Intel Xeon Platinum 8280进行，实验系统配置如表\ref{tab:os-8280}，测试使用1080p序列，编码器配置如表\ref{tab:svt-lat}。对测试结果的分析包括对各编码过程使用的CPU时间与各编码过程的延迟分布两类。

本章的延迟测试与章节\ref{sec:jnd-test}中对JND算法的测试使用平台不同，分别是在搭载Intel Xeon Platinum 8280的服务器与搭载Intel Core i7-6700HQ的个人笔记本上完成。原因是SVT-AV1在个人笔记本下的编码速度远达不到实时水平。因此所有关于延迟的测试都在服务器上完成，而对所提算法进行评估时，可以从使用CPU时间进行分析比较，为实验方便考虑而在个人笔记本电脑上完成。为了降低操作系统调度造成的测试结果波动，测试时将CPU的频率策略调整到“Performance”。

\begin{table}[!hpt]
	\renewcommand{\arraystretch}{0.9}
	\caption{延迟测试实验系统配置}
	\label{tab:os-8280}
	\centering
	\begin{tabular}{lc} \toprule
		项目& 参数  \\ \midrule
		OS:     &Ubuntu 18.04.4 LTS\\
		Kernel: & 4.15.0-96-generic\\
		CPU:    &Intel Xeon Platinum 8280 (112) @ 4.000GHz\\
		RAM:    &93GB\\
		GCC:    &v7.5.0\\
		SVT-AV1: & v0.8.1\\ \bottomrule
	\end{tabular}
\end{table}

\begin{table}[!hpt]
	\renewcommand{\arraystretch}{0.9}
	\caption{SVT-AV1编码器延迟测试参数配置}
	\label{tab:svt-lat}
	\centering
	\begin{tabular}{lc} \toprule
		项目& 参数  \\ \midrule
		preset     &8\\
		pred-struct& LDP\\
		lookahead    &0\\
		fps    &60\\
		GoP    &60\\
		asm    & up tp avx2\\
		bitdepth & 8\\
		hierarchicalLevels  & 4 \\
		rc & CQP\\ \bottomrule
	\end{tabular}
\end{table}

图\ref{fig:cpu-ana}展示了SVT-AV1编码器的各编码过程所用的CPU时间占比，测试发现，SVT-AV1编码器的CPU密集型任务主要分布在ENCDEC、ME、PD三个编码过程中，其中ENCDEC过程所用的CPU时间占总CPU时间的55\%，ME过程所用的CPU时间占总CPU时间的34\%。

\begin{figure}[!htp]
		\centering
		\includegraphics[width=0.75\textwidth]{cputime_analysis.png}
		\caption{SVT-AV1编码器各编码过程使用CPU时间分析图}
		\label{fig:cpu-ana}
\end{figure}
图\ref{fig:cpu-ana}展示了SVT-AV1编码器编码延迟在各编码过程中的分布，测试结果表明，SVT-AV1的编码延迟主要由层级LDP结构下调度产生，特别集中在PM过程和PD过程的调度上，而上述提到的CPU密集型任务ENCDEC过程与ME过程，则由于在SVT架构下的高度并行化在延迟分布上的占比低于其CPU时间使用占比。

\begin{figure}[!htp]
	\centering
	\includegraphics[width=0.75\textwidth]{latency_analysis.png}
	\caption{SVT-AV1编码器编码延迟在各编码过程分布图}
	\label{fig:lat-ana}
\end{figure}

\paragraph{PD\_sche} PD\_sche造成的延迟是由于图像决策过程（PD）负责设置帧预测结构，与场景变化检测，默认设置了6帧宽的滑动窗口，PD过程等待当前帧之后的6帧图像到达以后再对当前帧进行决策。因此，在实时编码时会引入6帧的输入延迟，对于30fps的视频流，这个延迟大约有200ms。

\paragraph{PM\_sche} 由于GoP结构为层级LDP，编码并不按照输入帧顺序进行，而是根据层级顺序编码，因此，在实时编码时，沿显示顺序观察，SVT-AV1编码器需要首先完成显示顺序靠后的低层级视频帧编码，满足参考关系后，通过反馈信令使得PM过程启动显示顺序靠前但层级较高的视频帧的编码。

GoP层级会影响PM\_sche的等待时间，但是减少GoP层级并不能降低编码延迟，原因在GoP层级上存在并行程度与依赖关系的权衡：提高GoP层级会使帧依赖关系变复杂，但是可以并行编码的视频帧增加了；降低GoP层级虽然可以减少PM\_sche的等待时间，但是，因为SVT-AV1本身的编码速度达不到实时，事实上会增加等待依赖帧编码的时间。测试表明，在SVT-AV1的实时编码测试中，层级设置越小，编码延迟越高。

\paragraph{PAK\_sche} 在GoP结构为层级LDP时，显示顺序靠后的低层级视频帧的编码会早于显示顺序靠前的高层级视频帧，而编码结果的输出按显示顺序进行。在PAK过程有重排序队列强制按照显示顺序将熵编码的结果打包，而提前完成了的显示顺序靠后的低层级视频帧会等待它之前的帧完成打包后才执行打包，因此产生了PAK\_sche。

\paragraph{overhead} SVT架构中各个编码过程实例化为不同数量的线程，各编码过程之间的数据传递和控制管理通过SVT系统资源管理器控制。过程间通信不可避免的有一些额外开销，这里的overhead表示了这些架构引起的开销总和。

\section{SVT架构的延迟优化}

SVT-AV1本身不是为编码低延迟视频流而设计，因此在一些细节需要进一步优化，本章提出了对SVT架构在低延迟上的一些优化实践。

\subsection{RESOURCE过程的EOS优化}
  在RESOURCE过程中，需要在收到下一帧的输入后才会将当前帧发送给下一级PA过程。这种延后一帧输出的机制是因为流结束标志EOS（End of Stream）设置需要，EOS标记用于表示当前帧是输入流的最后一帧。编码器在发送完最后一帧的数据后，会再发送一个带有EOS标记的空包，指示编码器终止编码过程。

  这样设计的机制在普通视频流编码中是合理的。但是对于我们要求的低延迟编码，EOS机制意味着额外的一个帧输入间隔延迟，对于30fps的流，这个延迟为33ms，相对较大。对于低延迟实时流媒体编码我们可以假设输入的视频流的总帧数是未知的，RESOURCE过程在收到一帧图像后立刻发送给下一级的PA过程，在流需要停止的时候才发送EOS包。

\subsection{PD过程的滑动窗口优化}
	在上一章节的分析中提到PD过程中因为滑动窗口机制产生的PD\_sche延迟，可以通过关闭场景变化检测将该滑动窗口的宽度设定为0，从而消除这部分的延迟。图\ref{fig:lat-ana-pd}展示了优化后的延迟测试结果，与优化前的图\ref{fig:lat-ana}相比，占总延迟高达40\%的PD\_sche延迟完全消除，平均编码延迟从优化前$\sim 420$ms降低至$\sim 240$ms。

	\begin{figure}[!htp]
		\centering
		\includegraphics[width=0.75\textwidth]{latency_analysis_pd.png}
		\caption{优化PD\_sche后SVT-AV1编码器编码延迟在各编码过程分布图}
		\label{fig:lat-ana-pd}
	\end{figure}

\subsection{分Tile编码优化}
	在AV1视频编码中，Tile\cite{a.fuldsethfuldsethTiles}表示尽管可以独立编码和解码的矩形区域。由于Tile划分，会降低像素数据中存在的相关性，降低了编码效率；但是，Tile的划分增加了编码器的并行效率，可有效降低编码延迟\cite{misraOverviewTilesHEVC2013}。

	AV1编码标准支持分Tile编码。根据AV1比特流规范\cite{rivazAV1BitstreamDecoding2019}中Annex A.3，对于1920x1080p@30fps的应用，限制Tile最大划分数为32，限制Tile最大列划分数为8。在AV1中，Tile的划分数量必须为2的指数次。在SVT-AV1编码器中，分Tile编码可以提高ENCDEC过程的并行程度，从而降低ENCDEC过程的延迟。ENCDEC过程延迟的降低使得单帧编码延迟下降，这也将使依赖于单帧编码延迟的调度延迟PAK\_sche和PM\_sche下降。

  出于性能考虑，SVT-AV1默认的分Tile机制限制在只能分行，不能分列。这导致编码过程中，每个Tile编码的波形并行的Tile宽度没有发生变化，在一行上的传播次数不变，使得分Tile的编码延迟增益十分有限。为了达到更低的编码延迟，这里选择牺牲一部分编码效率来提高并行率，降低编码延迟。

  图\ref{tab:tiles-bdrate}展示了不同Tile划分下的BD-Rate变化，图\ref{tab:tiles-latency}展示了不同Tile划分下的延迟变化，因为量化参数QP影响编码延迟，QP越大，编码速度越快，编码延迟越低，这里取QP为31的数据做图，表格中的灰色部分表示在由于Tile划分数量的限制被禁止的划分情况。图\ref{tab:tiles-bdrate}表明，分Tile时编码效率有少量损失，且编码效率随划分数量增加而递减；总Tile划分数量一定时，单方向划分与双方向划分相比会损失更多的编码效率。

	\begin{table}[!hpt]
		%	\renewcommand{\arraystretch}{0.9}
		\caption{不同Tile划分与对应的BD-Rate变化}
		\label{tab:tiles-bdrate}
		\centering
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			\diagbox[height=25pt]{col}{row} &    1    &   2    &   4    &          8          &         16          &         32          \\ \hline
			               1                & 0.00\%  & 0.65\% & 1.51\% &       1.86\%        &       2.06\%        &       3.92\%        \\ \hline
			               2                & -0.48\% & 0.21\% & 2.04\% &       2.48\%        &       3.03\%        & \cellcolor{gray!50} \\ \hline
			               4                & 0.28\%  & 0.90\% & 3.27\% &       3.96\%        & \cellcolor{gray!50} & \cellcolor{gray!50} \\ \hline
			               8                & 1.88\%  & 2.72\% & 4.85\% & \cellcolor{gray!50} & \cellcolor{gray!50} & \cellcolor{gray!50} \\ \hline
		\end{tabular}
	\end{table}
  图\ref{tab:tiles-latency}表明，对行方向的Tile划分对编码延迟降低的贡献很小，而对列方向划分对编码延迟降低更有效果。这个结果符合理论预期，因为1920x1080的帧比例为16：9，在波形并行模型下，决定波形传播总延迟的是Tile中超级块数量更多的行或列方向，因此划分更多列方向有利于均衡行与列方向的超级块数量，从而降低总编码延迟。



	% 这张表格说明之后系统里应该选择row1 col2（或者22）的划分做tradeoff
	\begin{table}[!hpt]
		%	\renewcommand{\arraystretch}{0.9}
		\caption{不同Tile划分的编码延迟（ms）变化（QP=31）}
		\label{tab:tiles-latency}
		\centering
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			\diagbox[height=25pt]{col}{row} &  1  &  2  &  4  &          8          &         16          &         32          \\ \hline
			               1                & 240 & 260 & 264 &         240         &         220         &         156         \\ \hline
			               2                & 246 & 180 & 167 &         155         &         153         & \cellcolor{gray!50} \\ \hline
			               4                & 198 & 162 & 132 &         136         & \cellcolor{gray!50} & \cellcolor{gray!50} \\ \hline
			               8                & 164 & 143 & 122 & \cellcolor{gray!50} & \cellcolor{gray!50} & \cellcolor{gray!50} \\ \hline
		\end{tabular}
	\end{table}


	综上，通过使用Tile划分并选择合适的行、列划分数量，可以进一步优化编码延迟。在降低0.21\%BD-Rate时，可以降低25\%的延迟，降低0.90\%BD-Rate时，可以降低33\%的延迟。

	\section{本章小结}

	本章阐述了对于SVT-AV1编码器的低延迟优化工作。首先简要介绍了SVT-AV1编码器的架构、其系统资源管理器的原理、SVT架构中的三重并行与多阶段分区、模式选择决策。然后，介绍了对于SVT-AV1架构的编码延迟profile工具，该工具对后续的优化方向与测试结果起指导作用。分析了SVT-AV1编码器的的编码延迟来源，并对延迟来源的主要组成部分进行了分析。根据延迟分析结果，对SVT架构进行了延迟优化，包括：
	\begin{enumerate}
		\item 对RESOURCE过程的EOS优化，解决了EOS机制导致的1帧输入延迟；
		\item 消除了在PD过程中因为滑动窗口机制产生的高PD\_sche延迟；
		\item 启用分tile编码，并分析了不同Tile划分对编码效率和编码延迟的影响，为后续选择最优的编码效率-编码延迟Tile划分方案提供了指导。
	\end{enumerate}
